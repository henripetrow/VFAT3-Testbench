process(clk) 
begin
	if rising_edge(clk) then
		if fifo_in_valid = '1' then
			leds(3) <= '1';
		end if;
		if fifo_in_empty = '1' then
			leds(2) <= '1';
		end if;
		if fifo_in_full = '1' then
			leds(1) <= '1';
		end if;
		if reset <= '1' then
			leds(0) <= reset;
		end if;
	end if;
end process;
		
		
when IDLE =>
	leds(7) <= '1';
	if ipbus_in.ipb_strobe = '1' and ipbus_in.ipb_write = '1' then
		state <= W;
	elsif ipbus_in.ipb_strobe = '1' and ipbus_in.ipb_write = '0' then
		state <= R;
	end if;
when W =>
	leds(6) <= '1';
	data_to_fifo <= ipbus_in.ipb_wdata;
	write_fifo_en <= '1';
	ipbus_out <= (ipb_ack => '1', ipb_err => '0', ipb_rdata => (others => '0'));
	state <= RESET;
when R =>
	leds(5) <= '1';
	read_fifo_en <= '1';
	state <= ACK;
when ACK =>				
	if fifo_valid = '1' then
		leds(4) <= '1';
		ipbus_out <= (ipb_ack => '1', ipb_err => '0', ipb_rdata => data_from_fifo);
		state <= RESET;
	elsif fifo_valid = '0' then
		ipbus_out <= (ipb_ack => '1', ipb_err => '0', ipb_rdata => (others => '1'));
		state <= RESET;
	end if;
when RESET =>
	data_to_fifo <= (others => '0');
	write_fifo_en <= '0';
	read_fifo_en <= '0';
	ipbus_out.ipb_ack <= '0';
	state <= IDLE;
when others =>
	data_to_fifo <= (others => '0');
	write_fifo_en <= '0';
	read_fifo_en <= '0';
	ipbus_out <= (ipb_ack => '0', ipb_err => '0', ipb_rdata => (others => '0'));
	state <= IDLE;
end case;